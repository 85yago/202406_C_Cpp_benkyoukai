# 01 環境構築とC言語ことはじめ

## 環境構築

### dockerで環境を作る

基本はこのリポジトリをcloneすれば使えるようにしてあります。

コンテナの立ち上げの初回は5分くらい掛かりました。
dockerhubへimageを上げとくか迷ったけど面倒なのでbuildを各PCに任せます。

git cloneしてvscodeでフォルダを開いてください。
その後、F1で`Dev Containers`を入力してコンテナで開いてください。

コンテナの中に入って作業が出来るようになります。
vscodeの左下に`開発コンテナー: Existing Dockerfile`となっていることを確認してください。

これで環境構築が終わるはずです。

### 環境に何が入っているか？

超大雑把に言えば、GNU Compiler Collection、GCCがCで書かれたプログラムを動かすために必要なソフトになります。
G++はC++で書かれたプログラムを動かすために必要なソフトです。
どっちもとりあえず入れてあります。

[cc, gcc, g++の違い - kamocyc’s blog](https://kamocyc.hatenablog.com/entry/2020/01/23/075331)

GDBはデバッガです。遠くないうちに解説しますが、プログラムの挙動を見るのに使うソフトです。

## Cことはじめ

そこらへんに腐るほど解説本・記事はあるので、説明はあんまり深入りしないと思います。
atcoderのA問題は困らず書けるとこくらいを目指しますが、それ以外もかじります。

Cはこんな感じのコードです。

`1.c`
```C
#include <stdio.h>

int main() {
    int a = 10;
    int b = 20;
    int c = a + b;
    printf("c = %d\n", c); // c = 30

    printf("hello, world!\n"); // hello, world!

    int e; // お行儀のよくない例

    return 0;
}

```

このプログラムは足し算して、結果を出力して、ハローワールドを出力して、終了します。

ほとんどの行の終わりにはセミコロン（`;`）を置きます。拡張子は`.c`とすることがほとんどです。

`//`から始まる部分はコメントで、動作に関係ないです。

このコードを、適当な名前を付けて保存し`F5`を押して実行してみてください。
（事前に設定してあるのでこれで動くようになっています）

![出力例](1.png)

多分こんな感じの出力が出るようになっていると思います。

"hello world"の部分を適当な文字列に変えてみて同様に実行し、出力が変化することを確かめましょう。

## 変数と型

`変数`は、数字や文字、文字列を入れておく箱のようなもの、です。
上の例で言えば、

```C
int a = 10;
```
これが変数を宣言して初期化している行で、`a`が変数です。`int`、`printf(...)`や`return 0`は変数ではありません。

そして、`a`の前に`int`と付いています。`integer`、整数の略です。
これが`型`です。
ある変数に入るものの性質を事前に定めておきます。
定められていないものは入りません。

つまり、
```C
int a = 10;
```
であれば、別の場所で値を代入
```C
a = 8476; // 8476という整数
```
してもよいです。

しかし、
```C
a = "4.5"; // 4.5という文字列を代入している
```
は出来なくなります。
これは、`a`という変数には`int`という整数が入る型を定めたので、文字列が入らなくなるためです。

多少互換性のある型なら、勝手に変換します。暗黙の型変換と呼ばれています。
例えばdouble→intは暗黙の型変換が発生し、intの範囲にある数字なら切り捨てで代入されます。

コンパイル（後述）時に暗黙の型変換を警告することもできます。この環境ではそのオプションがONになっています。

Cは「（弱い）静的型付け」という仕組みを採用しています。そのため、事前に型を定めておく必要があります。

対義語？は「動的型付け」とかになると思います。こちらは事前に型を定めなくてよいです。

```python
hoge = 100
hoge = "soo"
```

[「強い型付け」「弱い型付け」って言葉を知った! – Chomado's Blog](https://chomado.com/programming/type-safety/)

型の例をいくつか示しておきます。

|型|入るもの|例|
|--|--|--|
|short|符号付き16bit整数|32767|
|int|符号付き32bit整数|-100, 2147483647|
|unsigned int|符号なし32bit整数|4294967296|
|long long int|符号付き64bit整数|9223372036854775807|
|float|単精度(32bit)浮動小数点数（小数付きの数字）|10^35, 3.5547|
|double|倍精度(64bit)浮動小数点数（小数付きの数字）|10^300, 58484.195451477|
|char|文字（符号なし8bit整数）|'a', 'b', '?', '\n'|

また、入るもの側にも型があります。
例えば`0`と書けばintになりますし、`0.0`と書けばfloatかdouble、`'0'`と書けばcharになります。

では`int a = '0'`とするとどうなるでしょうか？

`'0'`は文字のゼロですが、コンピューターの中では符号なし整数で表されています。
そのため、`a=48`となります。
（asciiコード、unicodeなどでググってください）

終わりの方で`int e;`としていますが、これは悪い例です。

昔はeに何が入ってるか予想できないので、変数の宣言と同時に`=`を使って初期化を行えと言われました。
試したところ、今でも何が入るかわからないので、後で忘れてバグらせないよう初期化しましょう。

試しに、`int a;`として実行すると挙動が分かります。

### 補足1

1bitは一桁の2進数であらわせる情報。`0(2) = 0(10)`、`1(2) = 1(10)`、`10(2) = 2(10)`。
`11101001(2)`ならば2進数で8桁必要なので8bitであらわせる。

8bit（ビット） = 1byte（バイト）。1バイトが8bitを指さない場合があるので、厳密に言いたいときは1オクテットとか言ったりする、大体バイトでいい。

`浮動小数点数`は小数点が動く数のイメージ。
Cで使われているのは符号、仮数部、指数部で構成されている。
例えば、`-1943.29`を`-1 * 194329 * 10^(-2)`みたいな感じで表す。
10^300 + 1を表そうとすると、`1 * 10...0001（300桁） * 10^300`になってしまうが、仮数部に割ける桁が10進数の数字で15桁ぐらいしかないので、1は切り捨てられちゃう。つまり`10^300 + 1 = 10^300`。

補足終わり。

## 変数を使う

変数を使うコードを書きます。

`int main`の中に適当な変数を追加してください。

```C
int d = 999;
char mozi = '=';
```

F5で実行してエラーが出なければ成功です。

## 出力する

上で追加した変数の中身を出力してみましょう。

追加した変数の下に`printf`を追加します。
printfは文字列をターミナルに出力する`関数`です。関数は次回説明します。

```C
float suuzi = 12345.6789;
char mozi = '=';

printf("%f\n", suuzi);
printf("%c\n", mozi);
```

`\n`は改行文字です。printfは自動的に改行してくれないので自分で入れる必要があります。
試しに無しで試してもらうと挙動が分かります。

printfの1つ目の`"%d"`の部分はどういう風に変数の中身を出力するかを決めています。
`%なんとか`の部分が後ろで指定する変数で置き換えられます。型によって異なります。

関数に渡す値や変数を`引数（ひきすう）`と言って、カンマで区切ります。

2つ目以降は出力したい変数を指定します。
```C
float suuzi2 = 12345.678;

printf("suuzi2 = %010.2f\n", suuzi2);
```

型ごとに`%なんとか`があります。
桁数指定（10.2の部分、整数部分と小数部分）や0埋め（010の0の部分）もできます。

詳しくはググってください。
「c printf」「printf フォーマット指定子」

[フォーマット指定子一覧](https://www.k-cube.co.jp/wakaba/server/format.html)

試しに`a - b`してその結果を出力してみましょう。
a-bの結果はintなので`%d`で出力できます。

出力がこんな感じになっていればよいです。
```
a - b = -10
```

### 補足2

四則演算（`+`、`-`、`*`、`/`）以外にも演算子がある。

割った余り（剰余）を計算してくれる`%`（`18 % 7 = 4, 9 % 3 = 0`）。

`a += 10`は`a = a + 10`の省略形。上5つの演算子の省略形がある。

他にもある。参考資料を貼るのでわからんくなったら各自で確認すること。

[C の演算子一覧](https://www602.math.ryukoku.ac.jp/Prog1/cops.pdf)

補足終わり。

## ここまでのコード例

```C
#include <stdio.h> // standard Input/Output header

int main() {
    int a = 10;
    int b = 20;
    int c = a + b;
    printf("c = %d\n", c);

    printf("aaa, ああああ!\n");

    float suuzi = 12345.6789;
    char mozi = '=';

    printf("%f\n", suuzi);
    printf("%c\n", mozi);

    float suuzi2 = 12345.6789;

    printf("suuzi2 = %010.2f\n", suuzi2);

    int d = a - b;
    printf("a - b = %d\n", d);
    printf("a - b = %d\n", a - b); // a-bが計算されて値になるのでこれでもよい

    return 0;
}

```

先頭のincludeはライブラリというものを読み込んでいます。

printfとか他の関数がまとめて入れてある辞書みたいなものを読み込んでいると思ってください。
他にも色々な辞書があります。`math.h`とか。

自分で作って置いて読み込むこともできます。ここでは解説しません。

## 手作業の温かみ

vscodeは便利なので雑に拡張機能を入れたらコードの実行ができてしまうのですが、これを手作業でやってみたいと思います。

まず、`.out`ファイルを削除しておいてください。これが目標となる成果物だからです。

次にターミナルを開きましょう。コンテナの中のvscodeから`ターミナル`から`新しいターミナル`で開きます。
`...benkyoukai# `となっていれば入力し始める準備が整っています。

プログラムが書いてあるファイルを`1.c`とします。
cdコマンドでこのファイルが置いてある階層に移動してください。
例えば、01フォルダに入っていれば`cd 01`で移動できます。

lsコマンドで確かめるとよいでしょう。

ターミナルで実行していくコマンドを並べていきます。
1. `gcc -c 1.c -o 1.o`
1. `gcc 1.o -o 1.out`
1. `./1.out` ここで実行される

この3段階で実行ファイルができあがります。
1. ソースコードをコンパイラ（gcc）でオブジェクトファイル(.oのファイル)にコンパイルする。
1. オブジェクトファイルをリンカ（これもgcc）でライブラリ（printfとか）とリンク（くっつけて）して実行ファイル(linuxでは拡張子が無かったりする、今回は.outにしている)にする。
1. 実行ファイルを実行する。

試しにできたファイルを開いてみてください。読めないと思います。
中身が01で書かれていて無理やり開こうとすると文字化けしているように見えるはずです。

コードそのままじゃ動いてないんだなぁということが分かってもらえればそれでOKです。

fileコマンドはそのファイルが何かを示してくれます。
それぞれこんな感じになります。

```console
# file 1.c
1.c: C source, Unicode text, UTF-8 text

# file 1.o
1.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped

# file 1.out
1.out: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f8654ad05c14bf9ba52b13842cd17672f30f9d2b, for GNU/Linux 3.2.0, not stripped
```

これらを、vscodeとC/C++拡張機能の力でいい感じにしています。
`.vscode/tasks.json`がF5押したときの正体です。

なので、実際は`gcc-13 -fdiagnostics-color=always -g 1.c -o 1.out`みたいなコマンドがF5の裏では実行されています。

## 質問とか

- Q: 使う型によってプログラムのサイズを小さくできたりする？64bitのlongと32bitのintを使い分けるみたいな。
  A: longは8byte、intは4byte。実行ファイルは`ls -alh`などで確認できるが数万byte～になるので、1変数だけなら誤差。
     ただし、数百万個の変数とかになってくると、半分や10分の1でも減らしたくなってくる場合がある。例えばAIの学習とかでFP32だとかINT8とか言っているのはそのレベルなのでちょっとでも容量や計算コストを減らしたいため。

## 定数

プログラム内で変更しない変数を型の前に`const`を付けることによって保護できます。
変数名は大文字で書くことが多いです。

```c
const int TEISU = 100;

TEISU = 8; // compile error!
```

円周率とかはこれで定義されていたような気がします。
（math.hのM_PI）

## 配列

同じ型の値をまとめて保存しておきたい場合があります。

`配列`を使えば実現できます。
```c
int a[10] = {0}; // 10個分のint型の配列を0で初期化、{}でもよい
a[9] = 93;
printf("a[0] = %d\n", a[0]); // 1個目のint、0
printf("a[8] = %d\n", a[8]); // 9個目のint、0
printf("a[9] = %d\n", a[9]); // 10個目のint、93

int b[5] = {1, 2, 3, 4, 5}; // 5個分のint型の配列を1～5で初期化
printf("b[2] = %d\n", b[2]); // 3個目のint、3
printf("b[4] = %d\n", b[4]); // 5個目のint、5

```

変数宣言時の`a[10]`の`10`は配列のサイズです。
何個分場所を確保するかを決めます。

昔は後からサイズが決まるような配列、つまりscanfで値を読み取ってその値で配列のサイズを決める、ということができませんでしたが、今は出来ます。
```c
int s = 0;
scanf("%d", &s);

int a[s] = {};
```
どうも`{}`でしか初期化できないようです。

値を読み書きするときは`[]`を使ってアクセスできます、添え字とか言ったりします。

## 入力を受け取る

ターミナルに出力するだけでなく、ターミナルから入力を受け取りたい場合があります。
こんな感じで書きます。

コード例
```c
printf("Aを入力してください。\n");
int A = 0;
scanf("%d", &A); // 入力待ちになる、打ち終わったらEnter

printf("A = %d\n", A);

float B = 0;
char C = 0;
printf("BとCを半角スペースで区切って入力してください。\n");
scanf("%f %c", &B, &C); // 入力待ちになる、半角スペース開けて入力

printf("B = %f, C = %c\n", B, C);
```

出力例
```
Aを入力してください。
54
A = 54
BとCを半角スペースで区切って入力してください。
15.1111111 (
B = 15.111111, C = (
```

scanfが入力を受け取る関数です。

1つ目はprintfと同じようなフォーマット指定子が来ます。

2つ目以降で受け取った値を入れる変数を指定しますが、その時変数名の前に`&`を置きます。
これはポインタという概念の話になるので明日以降にします。
今はおまじないです。

これで入力を受け取れます。
